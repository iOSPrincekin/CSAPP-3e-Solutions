#include <stdio.h>
/*
 * 给定一个浮点格式，有k位指数和n位小数，写出阶码E、尾数M、小数f和值V的公式。
 * 另外，请描述其位表示。
 *
 * A.数7.0。
 * B.能够被准确描述的最大奇整数。
 * C.最小的规格化的倒数。
 *
 *
 * */
/*
 *  bias = 2^(k-1)-1;
 *  E = e - Bias;
 *  M = 1 + f;
 *  V = 2^E * M;
 *  f = e1 / 2^k
 *
 * */
/**
 *  A.数7.0
 *  010111  k = 3 n = 2 s = 0
 *  01111   k = 2 n = 2 s = 0
 *
 * */
/**
 *  A.数7.0
 *  7.0 = 0b111.000
 *  M = 0b1.11, f = 0b0.11, E = 2, e = bias + E, V = 7.0
 *  bits
 *  0 10...01 110...
 *
 * */
/**
 *
 * Assume bias >> n
 * bigest odd number, M must be ob1.111111..., f = 0b0.11111111(n bits 1)
 * E = n, e = bias + E,
 * 2^E = 2^n
 * V = 2^E * M =>
 *   = 2^n * (1 + (2^n-1)/ 2^n)
 *   = 2^n * ((2^(n+1) - 1)/ 2^n)
 *   = 2^(n+1) -1;
 *
 *   0 bias+n 1111......
 *
 * */


/*
 *  C.最小的规格化的倒数。
 *  // 最小规格化数
 *  float minF；
 *  000000...100000
 *  bias = 2^(k-1)-1;
 *  e = 1;
 *  E = 1 - bias;
 *  f = 0;
 *  M = 1.0
 *  2^E = 2^(1-bias)
 *  V = 2^E * M
 *    = 2^(1-bias)
 *    = 2^(2-2^(k-1));
 *
 *  minF的倒数 dminF = 1 / V
 *                  = 2^(2^(k-1)-2)
 *  2^(n+1) = 2^(2^(k-1) - 2)    =>
 *  n+1 = 2^(k-1) - 2             =>
 *  n = 2^(k-1) - 3
 *
 *  k = 3, n = 1
 *
 *
 *  0 001 0   1 / 2
 *  倒数
 *  0 100 0   4
 *  满足
 *
 *  假如 ::
 *  k = 3, n = 2
 *
 *  0 001 00  1 / 4
 *  倒数
 *  0 101 00  4
 *
 *
 *
 *
 *
 *
 *
 * */



/*
 *  C.最小的规格化的倒数。
 *  M must be 0b1.00..., f = 0b0.000..., E = 1-bias
 *  V = 2^(1-bias)
 *  reciprocal
 *  V = 2^(bias - 1)
 *  M = 0b1.000000, f = 0b0.000..., E = bias-1,e = bias + E =>
 *  e = 2 * bias - 1;
 *    = 2 * (2^(k-1)-1)-1
 *    = 2^k - 3
 *
 *    0 11...101 000000000...
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * */
int main() {
    printf("Hello, World!\n");
    return 0;
}